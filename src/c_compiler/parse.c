// parser

#include "globals.h"
#include "util.h"
#include "scan.h"
#include "parse.h"

static TokenType token; /* 当前token */

// 11个递归函数的原型

static TreeNode *stmt_sequence(void);
static TreeNode *statement(void);
static TreeNode *if_stmt(void);
static TreeNode *repeat_stmt(void);
static TreeNode *assign_stmt(void);
static TreeNode *read_stmt(void);
static TreeNode *write_stmt(void);
static TreeNode *exp(void);
static TreeNode *simple_exp(void);
static TreeNode *term(void);
static TreeNode *factor(void);

// 2个辅助函数
/* 报错 */
static void syntaxError(char *message)
{
  fprintf(listing, "\n>>> ");
  fprintf(listing, "Syntax error at line %d: %s", lineno, message);
  Error = TRUE;
}

/* 匹配token并且赋值给当前token */
static void match(TokenType expected)
{
  if (token == expected)
    token = getToken();
  else
  {
    // 报错点1
    syntaxError("unexpected token -> ");
    printToken(token, tokenString); // 这个函数在util中
    fprintf(listing, "      ");
  }
}

/* 解析语句序列， 返回AST的根结点 */
TreeNode *stmt_sequence(void)
{
  TreeNode *t = statement();
  TreeNode *p = t;
  while ((token != ENDFILE) && (token != END) &&
         (token != ELSE) && (token != UNTIL))
  {
    TreeNode *q;
    match(SEMI);
    q = statement();
    if (q != NULL)
    {
      if (t == NULL)
        t = p = q; // 可能出现这种情况的原因：空语句
      else         /* now p cannot be NULL either */
      // 加入链表之中
      {
        p->sibling = q;
        p = q;
      }
    }
  }
  return t;
}

/* 解析一条语句
 * 并返回该语句的语法分析树的根结点
 * 通过 switch 语句判断当前词法单元的类型
 * 根据不同的类型调用对应的语句解析函数
 */
TreeNode *statement(void)
{
  TreeNode *t = NULL; // 不建结点
  switch (token)
  {
  case IF:
    t = if_stmt();
    break;
  case REPEAT:
    t = repeat_stmt();
    break;
  case ID:
    t = assign_stmt();
    break;
  case READ:
    t = read_stmt();
    break;
  case WRITE:
    t = write_stmt();
    break;
  // 报错点2
  default:
    syntaxError("unexpected token -> ");
    printToken(token, tokenString);
    token = getToken();
    break;
  }
  return t;
}

TreeNode *if_stmt(void)
{
  TreeNode *t = newStmtNode(IfK); // 新建结点
  match(IF);
  if (t != NULL)
    t->child[0] = exp(); // NULL检查内存申请是否成功
  match(THEN);
  if (t != NULL)
    t->child[1] = stmt_sequence();
  if (token == ELSE)
  {
    match(ELSE);
    if (t != NULL)
      t->child[2] = stmt_sequence();
  }
  match(END);
  return t;
}

TreeNode *repeat_stmt(void)
{
  TreeNode *t = newStmtNode(RepeatK);
  match(REPEAT);
  if (t != NULL)
    t->child[0] = stmt_sequence();
  match(UNTIL);
  if (t != NULL)
    t->child[1] = exp();
  return t;
}

TreeNode *assign_stmt(void)
{
  TreeNode *t = newStmtNode(AssignK);
  if ((t != NULL) && (token == ID))
    t->attr.name = copyString(tokenString);
  match(ID);
  match(ASSIGN);
  if (t != NULL)
    t->child[0] = exp();
  return t;
}

TreeNode *read_stmt(void)
{
  TreeNode *t = newStmtNode(ReadK);
  match(READ);
  if ((t != NULL) && (token == ID))
    t->attr.name = copyString(tokenString);
  match(ID);
  return t;
}

TreeNode *write_stmt(void)
{
  TreeNode *t = newStmtNode(WriteK);
  match(WRITE);
  if (t != NULL)
    t->child[0] = exp();
  return t;
}

TreeNode *exp(void)
{
  TreeNode *t = simple_exp();
  if ((token == LT) || (token == EQ))
  { // 这是可选部分
    TreeNode *p = newExpNode(OpK);
    if (p != NULL)
    { // 检查分配是否成功
      p->child[0] = t;
      p->attr.op = token;
      t = p;
    }
    match(token);
    if (t != NULL) // 这个检查是什么意思？
      t->child[1] = simple_exp();
  }
  return t;
}

TreeNode *simple_exp(void)
{
  TreeNode *t = term();
  while ((token == PLUS) || (token == MINUS)) // 这是重复部分
  {
    TreeNode *p = newExpNode(OpK);
    if (p != NULL)
    {
      p->child[0] = t;
      p->attr.op = token;
      t = p;
      match(token);
      t->child[1] = term();
    }
  }
  return t;
}

TreeNode *term(void)
{
  TreeNode *t = factor();
  while ((token == TIMES) || (token == OVER))
  {
    TreeNode *p = newExpNode(OpK);
    if (p != NULL)
    {
      p->child[0] = t;
      p->attr.op = token;
      t = p;
      match(token);
      p->child[1] = factor();
    }
  }
  return t;
}

TreeNode *factor(void)
{
  TreeNode *t = NULL;
  switch (token)
  {
  case NUM:
    t = newExpNode(ConstK);
    if ((t != NULL) && (token == NUM))
      t->attr.val = atoi(tokenString);
    match(NUM);
    break;
  case ID:
    t = newExpNode(IdK);
    if ((t != NULL) && (token == ID))
      t->attr.name = copyString(tokenString);
    match(ID);
    break;
  case LPAREN: // 左括号
    match(LPAREN);
    t = exp();
    match(RPAREN);
    break;
  default:
    // 报错点3
    syntaxError("unexpected token -> ");
    printToken(token, tokenString);
    token = getToken();
    break;
  }
  return t;
}

/* parser的首要功能  */
/* parse返回构建得到的语法树 */
TreeNode *parse(void)
{
  TreeNode *t;
  token = getToken();                       // 读入第一个token
  t = stmt_sequence();                      // 剩下交给这个函数
  if (token != ENDFILE)                     // 最后检查，不能留有token
    syntaxError("Code ends before file\n"); // 报错点4
  return t;
}
